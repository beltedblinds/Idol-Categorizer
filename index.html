<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ğŸ¶ Idol Categorizer</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    background: #111;
    color: #eee;
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1rem;
  }
  h1 { margin: 0.5rem 0 1rem; }
  img, video {
    max-width: 80vw;
    max-height: 60vh;
    border-radius: 1rem;
    box-shadow: 0 0 20px #0008;
    margin: 1rem 0;
  }
  video { background: #000; }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    justify-content: center;
    margin-bottom: 1rem;
  }
  button {
    font-size: 1.2rem;
    padding: 0.7rem 1.5rem;
    border-radius: 0.75rem;
    border: none;
    background: #333;
    color: white;
    cursor: pointer;
    transition: background 0.2s, transform 0.1s;
  }
  button:hover { background: #666; transform: scale(1.03); }
  #progress { margin-top: 0.5rem; font-size: 0.9rem; opacity: 0.8; }
  #save, #toggleUncat { background: #28a745; margin: 0.5rem; }
  #uncatOnly.active { background: #555; }
  button.active { background: #666; }
</style>
</head>
<body>
  <h1>ğŸ¶ Idol Categorizer</h1>

  <div class="controls" id="sourceButtons" style="margin-bottom:0.5rem;">
    <button id="btnMedia" class="active">ğŸ–¼ï¸ idols-media-01</button>
    <button id="btnMedia2">ğŸ–¼ï¸ idols-media-02</button>
  </div>

  <div id="imageContainer"><p>Loading items...</p></div>
  <div class="controls" id="categoryButtons"></div>

  <div class="controls">
    <button id="prev">â¬…ï¸ Previous</button>
    <button id="skip">â­ï¸ Skip</button>
    <button id="toggleSound">ğŸ”‡ Sound Off</button>
    <button id="uncatOnly">Show Only Uncategorized</button>
    <button id="save">ğŸ’¾ Save Categorized File</button>
  </div>

  <div id="progress"></div>

<script>
let remoteLinks = "https://raw.githubusercontent.com/beltedblinds/idols-media-01/main/idol_gallery_links.txt";
let localLinks  = "https://raw.githubusercontent.com/beltedblinds/Idol-Categorizer/main/idol_gallery_links.txt";
let saveName = "idol_gallery_links.txt";

const media2RemoteLinks = "https://raw.githubusercontent.com/beltedblinds/idols-media-02/main/idol_gallery_links_02.txt";
const media2LocalLinks  = "https://raw.githubusercontent.com/beltedblinds/Idol-Categorizer/main/idol_gallery_links_02.txt";
const media2SaveName    = "idol_gallery_links_02.txt";

const catsFile = "https://raw.githubusercontent.com/beltedblinds/Idol-Categorizer/main/categories.txt";

let mode = "media"; // "media" or "media2"
let allLines = [];
let categories = [];
let uncategorizedOnly = false;
let cachedUncatList = null;
let currentIndex = 0;
let soundEnabled = false; // START MUTED

async function loadText(url) {
  try {
    const r = await fetch(url + "?t=" + Date.now(), { cache: "no-store" });
    if (!r.ok) throw new Error("Not found");
    return await r.text();
  } catch (err) {
    console.error("Failed to load:", url, err);
    return "";
  }
}

async function init() {
  const [remoteText, localText, catsText] = await Promise.all([
    loadText(remoteLinks),
    loadText(localLinks),
    loadText(catsFile)
  ]);

  const remote = remoteText.split(/\r?\n/).filter(Boolean);
  const local  = localText.split(/\r?\n/).filter(Boolean);
  const normalize = str => str.replace(/\s+/g, "").replace("github.com", "raw.githubusercontent.com");

  const localMap = new Map(
    local.map(line => {
      const parts = line.split(",").map(x => x.trim());
      return [normalize(parts[1] || ""), line];
    })
  );

  const merged = [];
  for (const line of remote) {
    const parts = line.split(",").map(x => x.trim());
    const [name, url, thumb, cat] = parts;
    const key = normalize(url);

    if (localMap.has(key)) {
      let localLine = localMap.get(key);
      let [ln, lu, lthumb, lcat] = localLine.split(",").map(x => x.trim());
      const remoteThumb = thumb || "";
      if (lthumb !== remoteThumb) {
        lthumb = remoteThumb;
        localLine = `${ln}, ${lu}, ${lthumb}, ${lcat || ""}`;
      }
      merged.push(localLine);
    } else {
      merged.push(`${name}, ${url}, ${thumb || ""}, ${cat || ""}`);
    }
  }

  allLines = merged;
  categories = catsText.split(/\r?\n/).filter(Boolean);
  renderCategoryButtons();

  const firstUncatIndex = allLines.findIndex(line => {
    const parts = line.split(",").map(x => x.trim());
    return parts.length < 4 || !parts[3];
  });
  currentIndex = firstUncatIndex >= 0 ? firstUncatIndex : 0;
  showMedia();
}

function renderCategoryButtons() {
  const div = document.getElementById("categoryButtons");
  div.innerHTML = "";
  const list = filteredLines();
  const { idx } = list[currentIndex];
  const [, , , catsField = ""] = allLines[idx].match(/^([^,]+),\s*([^,]+),\s*([^,]+),?\s*(.*)$/).slice(1);
  const currentCats = catsField ? catsField.split(",").map(x => x.trim()).filter(Boolean) : [];


  categories.forEach(cat => {
    const btn = document.createElement("button");
    btn.textContent = cat;
    btn.classList.toggle("active", currentCats.includes(cat));
    btn.onclick = () => {
      setCategory(cat);
      renderCategoryButtons(); // update button highlights after toggle
    };
    div.appendChild(btn);
  });
}

function filteredLines() {
  if (!uncategorizedOnly) return allLines.map((line, idx) => ({ line, idx }));
  return cachedUncatList;
}

function getMediaType(url) {
  const ext = url.split(".").pop().toLowerCase();
  if (["mp4", "webm", "ogg"].includes(ext)) return "video";
  if (["gif", "jpg", "jpeg", "png", "webp"].includes(ext)) return "image";
  return "unknown";
}

function showMedia() {
  const list = filteredLines();
  if (currentIndex < 0) currentIndex = 0;
  if (currentIndex >= list.length) {
    document.getElementById("imageContainer").innerHTML = "<p>âœ… Categorization complete!</p>";
    document.getElementById("progress").textContent = "";
    return;
  }

  const { idx } = list[currentIndex];
  const [name, url, thumb, cat = ""] = allLines[idx].match(/^([^,]+),\s*([^,]+),\s*([^,]+),?\s*(.*)$/).slice(1);
  const container = document.getElementById("imageContainer");
  const type = getMediaType(url);

  if (type === "video") {
    container.innerHTML = `<h3>${name}</h3>
      <video src="${url}" autoplay loop ${soundEnabled ? "" : "muted"} playsinline controls onerror="this.style.display='none'"></video>
      <p>Category: ${cat || "(none)"}</p>`;
  } else if (type === "image") {
    container.innerHTML = `<h3>${name}</h3>
      <img src="${url}" alt="${name}" onerror="this.style.display='none'">
      <p>Category: ${cat || "(none)"}</p>`;
  } else {
    container.innerHTML = `<h3>${name}</h3><p>Unsupported media: ${url}</p>`;
  }

  document.getElementById("progress").textContent = `Item ${currentIndex + 1} of ${list.length}`;
  renderCategoryButtons();
}

function setCategory(cat) {
  const list = filteredLines();
  const { idx } = list[currentIndex];
  const [n, u, t, catsField = ""] = allLines[idx].match(/^([^,]+),\s*([^,]+),\s*([^,]+),?\s*(.*)$/).slice(1);


  // Get existing categories as array, split by comma, trim spaces
  let existingCats = catsField ? catsField.split(",").map(x => x.trim()).filter(Boolean) : [];

  // Toggle the selected category
  if (existingCats.includes(cat)) {
    existingCats = existingCats.filter(c => c !== cat); // remove if already selected
  } else {
    existingCats.push(cat); // add if not present
  }

  // Save back as comma + space separated list
  allLines[idx] = `${n}, ${u}, ${t}, ${existingCats.join(", ")}`;
  showMedia(); // re-render the media and category buttons
}


document.getElementById("skip").onclick = () => { currentIndex++; showMedia(); };
document.getElementById("prev").onclick = () => { currentIndex--; showMedia(); };
document.getElementById("uncatOnly").onclick = e => {
  uncategorizedOnly = !uncategorizedOnly;
  e.target.classList.toggle("active", uncategorizedOnly);
  cachedUncatList = uncategorizedOnly
    ? allLines.map((line, idx) => ({ line, idx })).filter(obj => {
        const parts = obj.line.split(",").map(x => x.trim());
        return parts.length < 4 || !parts[3];
      })
    : null;
  currentIndex = 0;
  showMedia();
};

document.getElementById("save").onclick = () => {
  const blob = new Blob([allLines.join("\n")], { type: "text/plain" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = saveName;
  a.click();
  URL.revokeObjectURL(a.href);
};

// Switch sources
function switchToMedia() {
  remoteLinks = "https://raw.githubusercontent.com/beltedblinds/idols-media-01/main/idol_gallery_links.txt";
  localLinks  = "https://raw.githubusercontent.com/beltedblinds/Idol-Categorizer/main/idol_gallery_links.txt";
  saveName    = "idol_gallery_links.txt";
  setActiveButton("btnMedia");
  mode = "media";
  currentIndex = 0;
  init();
}

function switchToMedia2() {
  remoteLinks = media2RemoteLinks;
  localLinks  = media2LocalLinks;
  saveName    = media2SaveName;
  setActiveButton("btnMedia2");
  mode = "media2";
  currentIndex = 0;
  init();
}

function setActiveButton(id) {
  ["btnMedia", "btnMedia2"].forEach(btnId =>
    document.getElementById(btnId).classList.toggle("active", btnId === id)
  );
}

document.getElementById("btnMedia").onclick = switchToMedia;
document.getElementById("btnMedia2").onclick = switchToMedia2;

document.getElementById("toggleSound").onclick = () => {
  soundEnabled = !soundEnabled;

  const btn = document.getElementById("toggleSound");
  btn.textContent = soundEnabled ? "ğŸ”Š Sound On" : "ğŸ”‡ Sound Off";

  const vid = document.querySelector("video");
  if (vid) vid.muted = !soundEnabled;
};


init();
</script>
</body>
</html>
