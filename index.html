<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ğŸ¶ Idol Categorizer</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    background: #111;
    color: #eee;
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1rem;
  }
  h1 { margin: 0.5rem 0 1rem; }
  img, video {
    max-width: 80vw;
    max-height: 60vh;
    border-radius: 1rem;
    box-shadow: 0 0 20px #0008;
    margin: 1rem 0;
  }
  video { background: #000; }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    justify-content: center;
    margin-bottom: 1rem;
  }
  button {
    font-size: 1.2rem;
    padding: 0.7rem 1.5rem;
    border-radius: 0.75rem;
    border: none;
    background: #333;
    color: white;
    cursor: pointer;
    transition: background 0.2s, transform 0.1s;
  }
  button:hover { background: #666; transform: scale(1.03); }
  #progress { margin-top: 0.5rem; font-size: 0.9rem; opacity: 0.8; }
  #save, #toggleUncat { background: #28a745; margin: 0.5rem; }
  #uncatOnly.active { background: #555; }
  button.active { background: #666; }
</style>
</head>
<body>
  <h1>ğŸ¶ Idol Categorizer</h1>

  <div class="controls" id="sourceButtons" style="margin-bottom:0.5rem;">
    <button id="btnMedia" class="active">ğŸ–¼ï¸ idols-media-01</button>
    <button id="btnMedia2">ğŸ–¼ï¸ idols-media-02</button>
    <button id="btnMedia3">ğŸ–¼ï¸ idols-media-03</button>
    <button id="btnMedia4">ğŸ–¼ï¸ idols-media-04</button>
  </div>

  <div id="imageContainer"><p>Loading items...</p></div>
  <div id="timelineContainer" style="width: 80vw; height: 12px; background: #333; border-radius: 6px; margin: 0.5rem 0; cursor: pointer; display: none;">
    <div id="timelineProgress" style="width:0%; height:100%; background:#28a745; border-radius:6px;"></div>
  </div>

  <div class="controls" id="categoryButtons"></div>

  <div class="controls">
    <button id="prev">â¬…ï¸ Previous</button>
    <button id="skip">â­ï¸ Skip</button>
    <button id="toggleSound">ğŸ”‡ Sound Off</button>
  
    <!-- GLOBAL VOLUME SLIDER -->
    <input id="volumeSlider" type="range" min="0" max="1" step="0.01" value="0.5"
           style="width:120px; accent-color:#28a745;">
    
    <button id="cat10or11">Show Only Positions</button>
    <button id="uncatOnly">Show Only Uncategorized</button>
    <button id="save">ğŸ’¾ Save Categorized File</button>
  </div>

  <!-- Catalog Button -->
  <div class="controls">
    <button id="catalogBtn">ğŸ“‚ Catalog</button>
  </div>
  
  <!-- Catalog Modal -->
  <div id="catalogModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000b; overflow:auto; padding:1rem; z-index:1000;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
      <input type="text" id="catalogSearch" placeholder="Search by name..." style="flex:1; padding:0.5rem; font-size:1rem; margin-right:0.5rem; border-radius:0.5rem; border:none;">
      <button id="closeCatalog">âŒ Close</button>
    </div>
    <div id="catalogGrid" style="display:grid; grid-template-columns: repeat(auto-fill,minmax(120px,1fr)); gap:1rem;"></div>
  </div>


  <div id="progress"></div>

<script>
let remoteLinks = "https://raw.githubusercontent.com/beltedblinds/idols-media-01/main/idol_gallery_links.txt";
let localLinks  = "https://raw.githubusercontent.com/beltedblinds/Idol-Categorizer/main/idol_gallery_links.txt";
let saveName = "idol_gallery_links.txt";

const media2RemoteLinks = "https://raw.githubusercontent.com/beltedblinds/idols-media-02/main/idol_gallery_links_02.txt";
const media2LocalLinks  = "https://raw.githubusercontent.com/beltedblinds/Idol-Categorizer/main/idol_gallery_links_02.txt";
const media2SaveName    = "idol_gallery_links_02.txt";

const media3RemoteLinks = "https://raw.githubusercontent.com/beltedblinds/idols-media-03/main/idol_gallery_links_03.txt";
const media3LocalLinks  = "https://raw.githubusercontent.com/beltedblinds/Idol-Categorizer/main/idol_gallery_links_03.txt";
const media3SaveName    = "idol_gallery_links_03.txt";

const media4RemoteLinks = "https://raw.githubusercontent.com/beltedblinds/idols-media-04/main/idol_gallery_links_04.txt";
const media4LocalLinks  = "https://raw.githubusercontent.com/beltedblinds/Idol-Categorizer/main/idol_gallery_links_04.txt";
const media4SaveName    = "idol_gallery_links_04.txt";


const catsFile = "https://raw.githubusercontent.com/beltedblinds/Idol-Categorizer/main/categories.txt";

let mode = "media"; // "media" or "media2"
let allLines = [];
let categories = [];
let uncategorizedOnly = false;
let cachedUncatList = null;
let currentIndex = 0;
let soundEnabled = false; // START MUTED
let globalVolume = 0.5; // default volume
let currentPartIndex = 0;
let partDurations = [];   // durations of each part in seconds
let totalDuration = 0;    // sum of part durations
let videoElement = null;  // current video element reference
let urls = [];            // array of video URLs for multipart videos

let cat10or11Only = false;
let cachedCat10or11List = null;

async function preloadVideoDurations(urls) {
  const durations = [];
  for (const u of urls) {
    durations.push(await new Promise(resolve => {
      const vid = document.createElement("video");
      vid.src = u;
      vid.onloadedmetadata = () => resolve(vid.duration || 0);
      vid.onerror = () => resolve(0);
    }));
  }
  return durations;
}


async function loadText(url) {
  try {
    const r = await fetch(url + "?t=" + Date.now(), { cache: "no-store" });
    if (!r.ok) throw new Error("Not found");
    return await r.text();
  } catch (err) {
    console.error("Failed to load:", url, err);
    return "";
  }
}

async function init() {
  const [remoteText, localText, catsText] = await Promise.all([
    loadText(remoteLinks),
    loadText(localLinks),
    loadText(catsFile)
  ]);

  const remote = remoteText.split(/\r?\n/).filter(Boolean);
  const local  = localText.split(/\r?\n/).filter(Boolean);
  const normalize = str => str.replace(/\s+/g, "").replace("github.com", "raw.githubusercontent.com");

  const localMap = new Map(
    local.map(line => {
      const parts = line.split(",").map(x => x.trim());
      return [normalize(parts[1] || ""), line];
    })
  );

  const merged = [];
  for (const line of remote) {
    const parts = line.split(",").map(x => x.trim());
    const [name, url, thumb, cat] = parts;
    const key = normalize(url);

    if (localMap.has(key)) {
      let localLine = localMap.get(key);
      let [ln, lu, lthumb, lcat] = localLine.split(",").map(x => x.trim());
      const remoteThumb = thumb || "";
      if (lthumb !== remoteThumb) {
        lthumb = remoteThumb;
        localLine = `${ln}, ${lu}, ${lthumb}, ${lcat || ""}`;
      }
      merged.push(localLine);
    } else {
      merged.push(`${name}, ${url}, ${thumb || ""}, ${cat || ""}`);
    }
  }

  allLines = merged;
  categories = catsText.split(/\r?\n/).filter(Boolean);
  renderCategoryButtons();

  const firstUncatIndex = allLines.findIndex(line => {
    const parts = line.split(",").map(x => x.trim());
    return parts.length < 4 || !parts[3];
  });
  currentIndex = firstUncatIndex >= 0 ? firstUncatIndex : 0;
  showMedia();
}

function renderCategoryButtons() {
  const div = document.getElementById("categoryButtons");
  div.innerHTML = "";
  const list = filteredLines();
  const { idx } = list[currentIndex];
  const [, , , catsField = ""] = allLines[idx].match(/^([^,]+),\s*([^,]+),\s*([^,]+),?\s*(.*)$/).slice(1);
  const currentCats = catsField ? catsField.split(",").map(x => x.trim()).filter(Boolean) : [];


  // Decide which range of categories to show
  let displayCats = [];
  if (cat10or11Only) {
    displayCats = categories.slice(12, 18); // show categories 13â€“18
  } else {
    displayCats = categories.slice(0, 12);  // show categories 1â€“12
  }
  
  displayCats.forEach(cat => {
    const btn = document.createElement("button");
    btn.textContent = cat;
    btn.classList.toggle("active", currentCats.includes(cat));
    btn.onclick = () => {
      setCategory(cat);
      renderCategoryButtons(); // update button highlights after toggle
    };
    div.appendChild(btn);
  });
}

function filteredLines() {
  if (uncategorizedOnly) return cachedUncatList;
  if (cat10or11Only) return cachedCat10or11List;
  return allLines.map((line, idx) => ({ line, idx }));
}


function getMediaType(url) {
  const ext = url.split(".").pop().toLowerCase();
  if (["mp4", "webm", "ogg", "mov"].includes(ext)) return "video";
  if (["gif", "jpg", "jpeg", "png", "webp"].includes(ext)) return "image";
  return "unknown";
}

async function showMedia() {
  const list = filteredLines();
  if (currentIndex < 0) currentIndex = 0;
  if (currentIndex >= list.length) {
    document.getElementById("imageContainer").innerHTML = "<p>âœ… Categorization complete!</p>";
    document.getElementById("progress").textContent = "";
    document.getElementById("timelineContainer").style.display = "none";
    return;
  }

  const { idx } = list[currentIndex];
  const [name, url, thumb, cat = ""] = allLines[idx].match(/^([^,]+),\s*([^,]+),\s*([^,]+),?\s*(.*)$/).slice(1);
  const container = document.getElementById("imageContainer");
  const type = getMediaType(url);

  if (type === "video") {
    urls = url.split(";").map(x => x.trim());  // support multipart videos
    currentPartIndex = 0;
    partDurations = await preloadVideoDurations(urls);
    totalDuration = partDurations.reduce((a,b)=>a+b,0);


    container.innerHTML = `<h3>${name}</h3>
      <video id="mediaVideo" autoplay ${soundEnabled ? "" : "muted"} playsinline controls></video>
      <p>Category: ${cat || "(none)"}</p>`;

    videoElement = document.getElementById("mediaVideo");
    videoElement.src = urls[0];
    videoElement.volume = globalVolume;
    videoElement.muted = !soundEnabled;


    const timeline = document.getElementById("timelineContainer");
    const timelineProgress = document.getElementById("timelineProgress");
    
    if (urls.length > 1) {
      timeline.style.display = "block";   // only show for multipart videos
      timelineProgress.style.width = "0%";
    } else {
      timeline.style.display = "none";    // hide for single-part videos
    }



    // Update progress bar
    videoElement.ontimeupdate = () => {
      const elapsed = partDurations.slice(0, currentPartIndex).reduce((a, b) => a + b, 0) + videoElement.currentTime;
      if (totalDuration > 0) timelineProgress.style.width = (elapsed / totalDuration * 100) + "%";
    };

    // Click on timeline
    timeline.onclick = (e) => {
      const rect = timeline.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickRatio = clickX / rect.width;
      const targetTime = clickRatio * totalDuration;
    
      // Determine which part
      let accumulated = 0;
      let partIndex = 0;
      for (let i=0; i<partDurations.length; i++) {
        if (targetTime < accumulated + partDurations[i]) {
          partIndex = i;
          break;
        }
        accumulated += partDurations[i];
      }
      const timeInPart = targetTime - accumulated;
    
      if (partIndex !== currentPartIndex) {
        // Pause current video to prevent flicker
        videoElement.pause();
    
        // Create temp video to preload
        const tempVid = document.createElement("video");
        tempVid.src = urls[partIndex];
        tempVid.preload = "auto";
        tempVid.onloadedmetadata = () => {
          currentPartIndex = partIndex;
          videoElement.src = urls[currentPartIndex];
          videoElement.volume = globalVolume;
          videoElement.muted = !soundEnabled;
          videoElement.currentTime = timeInPart;
          videoElement.play();
        };

      } else {
        videoElement.currentTime = timeInPart;
      }
    };


    // --- NEW: Auto-play full sequence ---
    videoElement.onended = () => {
      if (currentPartIndex < urls.length - 1) {
        currentPartIndex++;
        videoElement.src = urls[currentPartIndex];
        videoElement.volume = globalVolume;
        videoElement.muted = !soundEnabled;
        videoElement.play();
        updateTotalDuration(currentPartIndex);
      } else {
        currentPartIndex = 0;
        videoElement.src = urls[0];
        videoElement.volume = globalVolume;
        videoElement.muted = !soundEnabled;
        videoElement.play();
        updateTotalDuration(0);
      }
    };

  }
  else if (type === "image") {
    document.getElementById("timelineContainer").style.display = "none";
    container.innerHTML = `<h3>${name}</h3>
      <img src="${url}" alt="${name}" onerror="this.style.display='none'">
      <p>Category: ${cat || "(none)"}</p>`;
  } else {
    document.getElementById("timelineContainer").style.display = "none";
    container.innerHTML = `<h3>${name}</h3><p>Unsupported media: ${url}</p>`;
  }

  document.getElementById("progress").textContent = `Item ${currentIndex + 1} of ${list.length}`;
  renderCategoryButtons();
}


function setCategory(cat) {
  const list = filteredLines();
  const { idx } = list[currentIndex];
  const [n, u, t, catsField = ""] = allLines[idx].match(/^([^,]+),\s*([^,]+),\s*([^,]+),?\s*(.*)$/).slice(1);

  // Get existing categories as array, split by comma, trim spaces
  let existingCats = catsField ? catsField.split(",").map(x => x.trim()).filter(Boolean) : [];

  // Toggle the selected category
  if (existingCats.includes(cat)) {
    existingCats = existingCats.filter(c => c !== cat); // remove if already selected
  } else {
    existingCats.push(cat); // add if not present
  }

  // Reorder existingCats to match the order in categories.txt
  existingCats.sort((a, b) => {
    const indexA = categories.indexOf(a);
    const indexB = categories.indexOf(b);
    // categories not found in categories.txt stay at the end
    return (indexA === -1 ? Infinity : indexA) - (indexB === -1 ? Infinity : indexB);
  });

  // Save back as comma + space separated list
  allLines[idx] = `${n}, ${u}, ${t}, ${existingCats.join(", ")}`;

  // Update category text without restarting media
  const catText = document.querySelector("#imageContainer p");
  if (catText) {
    catText.textContent = `Category: ${existingCats.join(", ") || "(none)"}`;
  }
  
  // Update button highlights only
  renderCategoryButtons();

}



document.getElementById("skip").onclick = () => { currentIndex++; showMedia(); };
document.getElementById("prev").onclick = () => { currentIndex--; showMedia(); };
document.getElementById("uncatOnly").onclick = e => {
  uncategorizedOnly = !uncategorizedOnly;
  e.target.classList.toggle("active", uncategorizedOnly);
  cachedUncatList = uncategorizedOnly
    ? allLines.map((line, idx) => ({ line, idx })).filter(obj => {
        const parts = obj.line.split(",").map(x => x.trim());
        return parts.length < 4 || !parts[3];
      })
    : null;
  currentIndex = 0;
  showMedia();
};

document.getElementById("save").onclick = () => {
  const blob = new Blob([allLines.join("\n")], { type: "text/plain" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = saveName;
  a.click();
  URL.revokeObjectURL(a.href);
};

document.getElementById("cat10or11").onclick = e => {
  cat10or11Only = !cat10or11Only;
  uncategorizedOnly = false; // disable other filter

  // Button visuals
  e.target.classList.toggle("active", cat10or11Only);
  document.getElementById("uncatOnly").classList.remove("active");

  // Get the 10th and 11th categories (index 9 and 10)
  const cat10 = categories[9];
  const cat11 = categories[10];

  cachedCat10or11List = cat10or11Only
    ? allLines.map((line, idx) => ({ line, idx })).filter(obj => {
        const parts = obj.line.split(",").map(x => x.trim());
        const cats = parts[3]
          ? parts[3].split(",").map(c => c.trim())
          : [];
        return cats.includes(cat10) || cats.includes(cat11);
      })
    : null;

  currentIndex = 0;
  showMedia();
};


// Switch sources
function switchToMedia() {
  remoteLinks = "https://raw.githubusercontent.com/beltedblinds/idols-media-01/main/idol_gallery_links.txt";
  localLinks  = "https://raw.githubusercontent.com/beltedblinds/Idol-Categorizer/main/idol_gallery_links.txt";
  saveName    = "idol_gallery_links.txt";
  setActiveButton("btnMedia");
  mode = "media";
  currentIndex = 0;
  init();
}

function switchToMedia2() {
  remoteLinks = media2RemoteLinks;
  localLinks  = media2LocalLinks;
  saveName    = media2SaveName;
  setActiveButton("btnMedia2");
  mode = "media2";
  currentIndex = 0;
  init();
}

function switchToMedia3() {
  remoteLinks = media3RemoteLinks;
  localLinks  = media3LocalLinks;
  saveName    = media3SaveName;
  setActiveButton("btnMedia3");
  mode = "media3";
  currentIndex = 0;
  init();
}

function switchToMedia4() {
  remoteLinks = media4RemoteLinks;
  localLinks  = media4LocalLinks;
  saveName    = media4SaveName;
  setActiveButton("btnMedia4");
  mode = "media4";
  currentIndex = 0;
  init();
}


function setActiveButton(id) {
  ["btnMedia", "btnMedia2", "btnMedia3"].forEach(btnId =>
    document.getElementById(btnId).classList.toggle("active", btnId === id)
  );
}

document.getElementById("btnMedia").onclick = switchToMedia;
document.getElementById("btnMedia2").onclick = switchToMedia2;
document.getElementById("btnMedia3").onclick = switchToMedia3;
document.getElementById("btnMedia4").onclick = switchToMedia4;

document.getElementById("toggleSound").onclick = () => {
  soundEnabled = !soundEnabled;

  const btn = document.getElementById("toggleSound");
  btn.textContent = soundEnabled ? "ğŸ”Š Sound On" : "ğŸ”‡ Sound Off";

  const vid = document.querySelector("video");
  if (vid) vid.muted = !soundEnabled;
};

// Global volume slider
const volumeSlider = document.getElementById("volumeSlider");

volumeSlider.oninput = (e) => {
  globalVolume = parseFloat(e.target.value);

  const vid = document.querySelector("video");
  if (vid) {
    vid.volume = globalVolume;
    if (globalVolume > 0 && !soundEnabled) {
      soundEnabled = true;
      document.getElementById("toggleSound").textContent = "ğŸ”Š Sound On";
      vid.muted = false;
    }
  }
};


// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") {
    // Right arrow â†’ Skip
    currentIndex++;
    showMedia();
  } else if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") {
    // Left arrow â†’ Previous
    currentIndex--;
    showMedia();
  }
});

// --- Place catalog JS here ---
const catalogBtn = document.getElementById("catalogBtn");
const catalogModal = document.getElementById("catalogModal");
const catalogGrid = document.getElementById("catalogGrid");
const catalogSearch = document.getElementById("catalogSearch");
const closeCatalog = document.getElementById("closeCatalog");

catalogBtn.onclick = () => {
  catalogModal.style.display = "block";
  renderCatalog();
};

closeCatalog.onclick = () => {
  catalogModal.style.display = "none";
};

function renderCatalog(filter = "") {
  catalogGrid.innerHTML = "";
  const list = allLines
    .map((line, idx) => {
      const parts = line.split(",").map(x => x.trim());
      const [name, url, thumb, catsField = ""] = parts;
      const cats = catsField ? catsField.split(",").map(c => c.trim()) : [];
      return { name, url, thumb, idx, cats };
    })
    .filter(item => {
      // Filter by search
      const matchSearch = item.name.toLowerCase().includes(filter.toLowerCase());
  
      // Filter by Positions Mode if active
      let matchPositions = true;
      if (cat10or11Only) {
        const cat10 = categories[9];
        const cat11 = categories[10];
        matchPositions = item.cats.includes(cat10) || item.cats.includes(cat11);
      }
  
      return matchSearch && matchPositions;
    });

  list.forEach(item => {
    const div = document.createElement("div");
    div.style.cursor = "pointer";
    div.style.textAlign = "center";

    const img = document.createElement("img");
    img.src = item.thumb || item.url; // use thumbnail if available
    img.alt = item.name;
    img.style.width = "100%";
    img.style.height = "auto";
    img.style.borderRadius = "0.5rem";
    img.style.boxShadow = "0 0 10px #0008";
    img.onerror = () => { img.style.display = "none"; };

    const caption = document.createElement("div");
    caption.textContent = item.name;
    caption.style.fontSize = "0.8rem";
    caption.style.marginTop = "0.3rem";

    div.appendChild(img);
    div.appendChild(caption);

    div.onclick = () => {
      const list = filteredLines(); // use the same filtered list as showMedia()
      const filteredIndex = list.findIndex(obj => obj.idx === item.idx);
      if (filteredIndex >= 0) {
        currentIndex = filteredIndex;
        showMedia();
        catalogModal.style.display = "none";
      }
    };


    catalogGrid.appendChild(div);
  });
}

// Filter catalog as you type
catalogSearch.addEventListener("input", (e) => {
  renderCatalog(e.target.value);
});


init();
</script>
</body>
</html>
